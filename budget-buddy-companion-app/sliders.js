/* *     Copyright (C) 2010-2016 Marvell International Ltd. *     Copyright (C) 2002-2010 Kinoma, Inc. * *     Licensed under the Apache License, Version 2.0 (the "License"); *     you may not use this file except in compliance with the License. *     You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *     Unless required by applicable law or agreed to in writing, software *     distributed under the License is distributed on an "AS IS" BASIS, *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *     See the License for the specific language governing permissions and *     limitations under the License. *//*** This is the JavaScript equivalent of the the sliders.xml module from the Controls library* https://github.com/Kinoma/kinomajs/blob/master/kinoma/kpr/libraries/Controls/src/controls/sliders.xml**/import { THEME } from 'theme';class SliderBehavior extends Behavior {	changeState(container, state) {		if (container.last) container.last.state = state;	}	getMax(container) {		return this.data.max;	}	getMin(container) {		return this.data.min;	}	getOffset(container, size) {		var min = this.getMin(container);		var max = this.getMax(container);		var value = this.getValue(container);		return Math.round(((value - min) * size) / (max - min));	}	getValue(container) {		return this.data.value;	}	onAdapt(container) {		this.onLayoutChanged(container);	}	onCreate(container, data) {		this.data = data;	}	onDisplaying(container) {		this.onValueChanged(container);	}	onTouchBegan(container, id, x, y, ticks) {		container.captureTouch(id, x, y, ticks);		this.changeState(container, 1);		this.onTouchMoved(container, id, x, y, ticks);	}	onTouchEnded(container, id, x, y, ticks) {		this.changeState(container, 0);	}	setOffset(container, size, offset) {		var min = this.getMin(container);		var max = this.getMax(container);		var value = min + ((offset * (max - min)) / size);		if (value < min) value = min;		else if (value > max) value = max;		this.setValue(container, value);	}	setValue(container, value) {		this.data.value = value;	}}export class HorizontalSliderBehavior extends SliderBehavior {	onLayoutChanged(container) {		var button = container.last;		var bar = button.previous;		var background = bar.previous;		var size = (background.width - button.width);		var offset = this.getOffset(container, size);		button.x = background.x + offset;		bar.width = button.width + offset;	}	onTouchMoved(container, id, x, y, ticks) {		var button = container.last;		var bar = button.previous;		var background = bar.previous;		var size = (background.width - button.width);		var offset = (x - (button.width >> 1) - background.x);		this.setOffset(container, size, offset);		this.onLayoutChanged(container);		this.onValueChanged(container);	}}export var HorizontalSlider = Layout.template($ => ({ 	active: true,	contents: [		Content($, { left: 0, right: 0, top: 0, bottom: 0, skin: THEME.horizontalSliderBarSkin, state: 0, }),		Content($, { left: 0, width: 30, top: 0, bottom: 0, skin: THEME.horizontalSliderBarSkin, state: 1, }),		Content($, { left: 0, width: 30, top: 0, bottom: 0, skin: THEME.horizontalSliderButtonSkin, state: 0, }),	]}));export class HorizontalLogSliderBehavior extends HorizontalSliderBehavior {	getOffset(container, size) {		var min = this.getMin(container);		var max = this.getMax(container);		var value = this.getValue(container);		var logMin = Math.log(min);		var maxv = Math.log(max);		return Math.round(((Math.log(value) - logMin) * size) / (maxv - logMin));	}	setOffset(container, size, offset) {		var min = this.getMin(container);		var max = this.getMax(container);		var logMin = Math.log(min);		var logMax = Math.log(max);		var value = Math.exp(logMin + (offset * (logMax - logMin) / size));		if (value < min) value = min;		else if (value > max) value = max;		this.setValue(container, value);	}}export class VerticalSliderBehavior extends SliderBehavior {	onLayoutChanged(container) {		var button = container.last;		var bar = button.previous;		var background = bar.previous;		var size = (background.height - button.height);		var offset = this.getOffset(container, size);		button.y = background.y + background.height - offset - button.height;		bar.height = button.height + offset;	}	onTouchMoved(container, id, x, y, ticks) {		var button = container.last;		var bar = button.previous;		var background = bar.previous;		var size = (background.height - button.height);		var offset = background.y + background.height - (y + (button.height >> 1));		this.setOffset(container, size, offset);		this.onLayoutChanged(container);		this.onValueChanged(container);	}}export var VerticalSlider = Layout.template($ => ({ 	active: true,	contents: [		Content($, { left: 0, right: 0, top: 0, bottom: 0, skin: THEME.verticalSliderBarSkin, state: 0, }),		Content($, { left: 0, right: 0, height: 30, bottom: 0, skin: THEME.verticalSliderBarSkin, state: 1, }),		Content($, { left: 0, right: 0, top: 0, height: 30, skin: THEME.verticalSliderButtonSkin, state: 0, }),	], }));export class VerticalLogSliderBehavior extends VerticalSliderBehavior {	getOffset(container, size) {		var min = this.getMin(container);		var max = this.getMax(container);		var value = this.getValue(container);		var logMin = Math.log(min);		var maxv = Math.log(max);		return Math.round(((Math.log(value) - logMin) * size) / (maxv - logMin));	}	setOffset(container, size, offset) {		var min = this.getMin(container);		var max = this.getMax(container);		var logMin = Math.log(min);		var logMax = Math.log(max);		var value = Math.exp(logMin + (offset * (logMax - logMin) / size));		if (value < min) value = min;		else if (value > max) value = max;		this.setValue(container, value);	}}